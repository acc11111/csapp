# 整数二进制码小记

#### 表示方式

对于一个有符号的二进制码来说，第一位是符号为，同时后面的位置就是直接读取大小就ok了

这时候可能会问，负数呢，负数怎么读取大小，下面以四位有符号的来解释

```
0011---表示3
1011---表示(-16+0+2+1)=-13这是表示-13
```

为什么会这样来表示呢

这是因为要完成一个闭环一样的表示

0111是最大正数，1000是最小的负数，可是0111+1即可变为1000，也就是最大正数之后就是接着最小的负数，这时候就是完成了一次循环，那再次从最小的负数开始下去，从-16开始向正数出发（这应该就是国内想要解释的时钟），也就是-16>-15>-14.........>当负数来到0也就是1111时，1111+1=10000，完成闭环，再次变成正数，这才存储的回环

附上CSAPP的截图，可以看到，负数和正数都是从最小开始计算，然后慢慢变大！**负数**是从$-2^{w-1}$，然后**正数**从0开始

#### 不同类型比较

当一个有符号的二进制和一个无符号的二进制进行比较的时候，有符号的二进制码会保持不变同时被读为不变情况下的无符号码，由于负数的记录方式，所以会发现，

- 负数和无符号整数0进行比较时，负数时更加大的

  ```
  a = 1111---表示-1
  b = 0000---表示0U
  此时-1二进制保持不变，但是按照无符号的规则读取则是 15，所以a > b
  ```

  

- 负数和有符号的0比较时，不会发生转换，所以0此时更大

#### 有趣的现象

解释一下这个的由来，`TMAX`就是`0111`，然后乘上2相当于左移一位，此时变为`1110`，再加上1就是`1111`即为`UMAX`

```
UMAX = 2*TMAX + 1
```

无限的循环：这个i来到0000之后会继续--，然后变成`1111`，即是`UMAX`，导致循环一直无限下去。因为这个数字当来到边界的时候就开始循环了

```c
int main(){
    unsigned i;
    for(i = n -1; i >= 0; i--){
        f(i)
    }
}
```

- 深入C

`sizeof()`返回的是无符号的整数`size_t >>> long unsigned`，所以也会和[有趣的现象](#### 有趣的现象)是一样的无限死循环

`unsigned`以及任何的运算出来的整数都会视为`>=0`

#### 扩展位数bits

左移一般来说都是直接在末尾添加0即可保持数值一致

但是对于右移来说添加的数字有可能会影响原有的数值大小，这里来解释特殊的右移动

```
1011---这里的最高位表示的-8
将其扩展一位
11011---这里扩展一位之后，相当于最高位（最左侧）是-16，但是由于计算的法则，左边数过来的第二个1变成了+8，此时-16+8=-8与原来的值是相当的，这可以使得扩展后的数值不变 
```

#### 有符号&无符号整数的加减法

这里插一个根据计组上课以及csapp-3里面的讲法，自己认识到，当一个数据溢出的时候，不管是如何溢出，反正$+2^n$或者$-2^n$以及倍数（但倍数不大可能）可以将数字回归到表示的最大范围内，则就是这个数字的表示方式

```
int a = 0111---表示7
int b = 0101---表示5

a + b = 1100---表示-4
此时应该读为-4，因为有符号的4bits表示的范围是-8至7，所以加上之后正常大小是12，但是此时已经溢出，所以是使用减去8也就是-8的运算来将数字拉回表示的范围内，为什么不是加8，因为加8还是在表示范围外，这是自己的一种看法
```

无符号的计算直接位数相加，不理进位

有符号相加直接看作是无符号（保持bits不变），直接相加，然后按照int方式来读

#### 乘法

乘法也没有很神秘，二进制的乘法可以使用十进制的方法计算，然后再用二进制表示出来，这是对于人来说的；然后乘法也是有截取机制的，多出来的都不要，无符号和有符号都是保持在bit不变的情况下

#### 移位

有时候乘除2的幂也会被优化为移位

`左移`：乘上2

`右移`：除上2

> 移位比乘法要快是因为移位只需要$log_2{n}$个时钟周期，但是乘法需要几个甚至十几个时钟周期

#### 除法

目前当代的电脑上除法仍然是很慢的，需要大概30个时钟周期

#### 补码=~原码+1

经典公式的相关知识

我们都知道一个负数的原码，加上自己的反码，应该为全一，此时表示的结果为-1

```
0101---想要表示绝对值为5
1010---表示为5的反码
两个相加为
1111---表示为-1
所以
原码 + 反码 = -1
```

#### Tmin

Tmin的相反数还是Tmin

1000

取反再加一0111 + 1 = 1000
